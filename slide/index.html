<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenStreetMap MCP開発実録: 大容量データ問題の解決</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">
    <style>
        .reveal {
            font-size: 32px;
        }
        .reveal h1 {
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .reveal h2 {
            font-size: 1.6em;
            color: #42affa;
        }
        .reveal h3 {
            font-size: 1.3em;
            color: #ffa500;
        }
        .reveal pre {
            font-size: 0.45em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .highlight-box {
            background: rgba(66, 175, 250, 0.1);
            border-left: 5px solid #42affa;
            padding: 20px;
            margin: 20px 0;
        }
        .problem-box {
            background: rgba(255, 107, 107, 0.1);
            border-left: 5px solid #ff6b6b;
            padding: 20px;
            margin: 20px 0;
        }
        .solution-box {
            background: rgba(81, 207, 102, 0.1);
            border-left: 5px solid #51cf66;
            padding: 20px;
            margin: 20px 0;
        }
        .metric {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: center;
        }
        .tool-list {
            text-align: left;
            font-size: 0.8em;
        }
        .tool-list ul {
            list-style: none;
            padding: 0;
        }
        .tool-list li {
            margin: 8px 0;
            padding-left: 20px;
        }
        .tool-list li::before {
            content: "✓ ";
            color: #51cf66;
            font-weight: bold;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            
            <!-- タイトルスライド -->
            <section>
                <h1>大容量APIデータを<br>LLMに渡さず<br>ファイル保存する手法</h1>
                <h2 style="color: #ffa500;">AIエージェントでMCP開発した際の<br>重要な気づきと解決策</h2>
                <p style="margin-top: 40px; font-size: 0.8em; color: #42affa;">
                    OpenStreetMap MCP開発での実体験
                </p>
                <p style="font-size: 0.6em; color: #888;">2025年11月</p>
            </section>

            <!-- AIエージェント開発背景 -->
            <section>
                <h2>AIエージェント（Claude Code）でMCP開発</h2>
                <div class="highlight-box">
                    <h3 style="margin-top: 0;">🤖 開発背景</h3>
                    <div class="tool-list">
                        <ul>
                            <li><strong>Claude Code</strong>を使ってOpenStreetMap MCP サーバーを開発</li>
                            <li><strong>12種類のツール</strong>で地理データ取得（建物、道路、施設など）</li>
                            <li><strong>Overpass API</strong>からOSMデータをGeoJSON形式で提供</li>
                            <li><strong>AIエージェント主導</strong>で段階的に機能を実装</li>
                        </ul>
                    </div>
                </div>
                <div class="solution-box">
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>AIエージェントの利点:</strong> 効率的な開発、ベストプラクティスの提案、包括的なテスト実装
                    </p>
                </div>
                <div class="problem-box">
                    <p style="margin: 0; text-align: center;">
                        <strong>しかし、AIエージェントが作った当初の仕様に重大な問題が...</strong>
                    </p>
                </div>
            </section>

            <!-- AIエージェントの当初仕様 -->
            <section>
                <h2>AIエージェントが作った当初の仕様</h2>
                
                <div class="problem-box">
                    <h3 style="margin-top: 0; color: #ff6b6b;">❌ 当初の仕様: APIレスポンスを直接LLMに返却</h3>
                    <pre><code class="language-javascript" data-trim>
// AIエージェントが実装した当初のコード
export async function getBuildings(client, args) {
  const osmData = await client.query(query);
  const geojson = osmToGeoJSON(osmData);
  
  return {
    content: [{
      type: 'text',
      text: JSON.stringify(geojson, null, 2)  // 🚨 巨大データを直接返す
    }]
  };
}
                    </code></pre>
                </div>

                <div class="highlight-box">
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>AIエージェントの想定:</strong> 「MCPツールはAPIデータをそのまま返すもの」<br>
                        → <strong>大容量データの場合のトークン消費を考慮していなかった</strong>
                    </p>
                </div>

                <div class="grid-2">
                    <div>
                        <h4>実際に起きた問題</h4>
                        <ul style="font-size: 0.8em; text-align: left;">
                            <li>建物数: 1,234件</li>
                            <li>GeoJSONサイズ: 2.3MB</li>
                            <li>トークン数: 約575,000</li>
                            <li>コスト: $11.50/リクエスト</li>
                        </ul>
                    </div>
                    <div>
                        <h4 style="color: #ff6b6b;">深刻な影響</h4>
                        <ul style="font-size: 0.8em; text-align: left; color: #ff6b6b;">
                            <li>コンテキスト圧迫</li>
                            <li>応答速度低下（5-10秒）</li>
                            <li>タイムアウトリスク</li>
                            <li>使用不可能なコスト</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 大容量APIの考慮事項 -->
            <section>
                <h2>大容量APIを扱う際の重要な考慮事項</h2>
                
                <div class="problem-box">
                    <h3 style="margin-top: 0;">⚠️ 大容量データAPIの特徴</h3>
                    <div class="tool-list">
                        <ul>
                            <li><strong>地理データAPI</strong>: OpenStreetMap、Google Maps等</li>
                            <li><strong>画像・動画API</strong>: メディア配信サービス</li>
                            <li><strong>大規模データセットAPI</strong>: 統計データ、ログデータ等</li>
                            <li><strong>検索結果API</strong>: 大量の結果を返すAPI</li>
                        </ul>
                    </div>
                </div>

                <div class="highlight-box">
                    <h3 style="margin-top: 0;">💡 事前に確認すべきポイント</h3>
                    <div class="grid-2">
                        <div class="tool-list">
                            <ul>
                                <li>レスポンスサイズの想定</li>
                                <li>1MBを超える可能性</li>
                                <li>トークン換算での計算</li>
                            </ul>
                        </div>
                        <div class="tool-list">
                            <ul>
                                <li>ページネーション機能</li>
                                <li>ファイルダウンロード機能</li>
                                <li>ストリーミング対応</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="solution-box">
                    <p style="margin: 0; text-align: center;">
                        <strong>教訓:</strong> AIエージェントと開発する際も、大容量APIの特性は<br>
                        <strong>人間が事前に考慮して指示する必要がある</strong>
                    </p>
                </div>
            </section>

            <!-- ファイル保存手法の解決策 -->
            <section>
                <h2>ファイル保存手法による解決策</h2>
                
                <div class="solution-box">
                    <h3 style="margin-top: 0; color: #51cf66;">✅ 新しい仕様: ファイル保存 + メタデータ返却</h3>
                    <pre><code class="language-javascript" data-trim>
export async function getBuildings(client, args) {
  const { output_path } = args;
  
  if (output_path) {
    // 🎯 ファイル保存手法: 大容量データをファイルに保存
    const result = await executeGeoJSONQuery(client, query, output_path);
    
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          status: 'success',
          message: '建物データをファイルに保存しました',
          file: output_path,              // ✅ ファイルパスのみ
          size: result.size,              // ✅ メタデータ
          feature_count: result.feature_count  // ✅ サマリー情報
        }, null, 2)
      }]
    };
  }
  // 小さなデータは従来通り直接返却
}
                    </code></pre>
                </div>
                
                <div class="highlight-box">
                    <h3 style="margin-top: 0;">💡 ファイル保存手法の核心</h3>
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>大容量データ → ファイル保存</strong><br>
                        <strong>LLMには → メタデータのみ返却</strong><br>
                        <strong>結果 → トークン消費を劇的に削減</strong>
                    </p>
                </div>
                
                <div class="metric" style="color: #51cf66;">
                    トークン使用量: 575,000 → 200 (99.97%削減)
                </div>
            </section>

            <!-- ファイル保存手法の実装詳細 -->
            <section>
                <h2>ファイル保存手法の実装詳細</h2>
                
                <div class="highlight-box">
                    <h3 style="margin-top: 0;">utils/file-downloader.js の核心実装</h3>
                    <pre><code class="language-javascript" data-trim>
export async function downloadToFile(url, query, outputPath) {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      const writeStream = createWriteStream(outputPath);
      let downloadedBytes = 0;

      res.on('data', (chunk) => {
        downloadedBytes += chunk.length;
        // 大容量ファイルの進行状況表示
        if (downloadedBytes % (1024 * 1024) === 0) {
          console.error(`Downloaded: ${(downloadedBytes/1024/1024).toFixed(1)} MB`);
        }
      });

      // 🔥 ストリーミング書き込みでメモリ効率化
      res.pipe(writeStream);
      
      writeStream.on('finish', () => {
        resolve({ 
          size: `${(downloadedBytes/1024/1024).toFixed(2)} MB`,
          bytes: downloadedBytes 
        });
      });
    });
    
    req.write(query);
    req.end();
  });
}
                    </code></pre>
                </div>

                <div class="solution-box">
                    <h3 style="margin-top: 0;">🎯 ファイル保存手法の利点</h3>
                    <div class="grid-2">
                        <div class="tool-list">
                            <ul>
                                <li><strong>メモリ効率</strong>: ストリーミング処理</li>
                                <li><strong>スケーラブル</strong>: 数百MB対応</li>
                                <li><strong>高速</strong>: 直接ディスク書き込み</li>
                            </ul>
                        </div>
                        <div class="tool-list">
                            <ul>
                                <li><strong>トークン節約</strong>: 99.9%削減</li>
                                <li><strong>コスト削減</strong>: $11→$0.004</li>
                                <li><strong>安定性</strong>: タイムアウト回避</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ファイル保存手法のアーキテクチャ -->
            <section>
                <h2>ファイル保存手法のアーキテクチャ</h2>
                
                <div style="font-size: 0.7em; text-align: left; font-family: monospace;">
                    <pre style="background: rgba(66, 175, 250, 0.1); padding: 20px; border-radius: 8px;">
🌍 大容量API (Overpass API)
   ↓ 🚨 従来: 直接LLMに返却 (575,000トークン)
   ↓ ✅ 新手法: ファイル保存
📦 utils/file-downloader.js
   ├─ downloadToFile() - HTTPSストリーミングダウンロード  
   └─ executeGeoJSONQuery() - OSM→GeoJSON変換+保存
   ↓
💾 output.geojson (2.3MB) ← 大容量データをファイルに保存
   ↓
🤖 LLMには軽量なメタデータのみ (200トークン)
   {
     "file": "./buildings.geojson",  ← ファイルパス
     "size": "2.3 MB",              ← サイズ情報 
     "feature_count": 1234          ← サマリー
   }
                    </pre>
                </div>
                
                <div class="solution-box">
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>ファイル保存手法の核心:</strong> 大容量データをLLMコンテキスト外に保持し、<br>
                        <strong>必要最小限のメタデータのみをLLMに提供</strong>
                    </p>
                </div>
            </section>

            <!-- ファイル保存手法の適用結果 -->
            <section>
                <h2>ファイル保存手法の適用結果</h2>
                
                <div class="solution-box">
                    <h3 style="margin-top: 0;">🎯 12種類のツール全てにファイル保存手法を適用</h3>
                    <div class="grid-2">
                        <div class="tool-list">
                            <h4>📍 大容量データ対応ツール</h4>
                            <ul>
                                <li>get_buildings（建物）</li>
                                <li>get_roads（道路）</li>
                                <li>get_amenities（施設）</li>
                                <li>get_waterways（水域）</li>
                                <li>get_green_spaces（緑地）</li>
                                <li>get_railways（鉄道）</li>
                            </ul>
                        </div>
                        <div class="tool-list">
                            <h4>🛠️ ファイル処理ユーティリティ</h4>
                            <ul>
                                <li>download_osm_data（生データ）</li>
                                <li>convert_to_geojson（変換）</li>
                                <li>test_connection（接続テスト）</li>
                                <li>get_api_stats（統計）</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="highlight-box">
                    <p style="margin: 0; text-align: center;">
                        <strong>統一設計: 全ツールでoptional output_pathパラメータ</strong><br>
                        小さなデータ: JSON直接返却 | 大容量データ: ファイル保存手法
                    </p>
                </div>

                <div class="problem-box">
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>重要:</strong> どのツールでも1MB以上のデータが想定される場合、<br>
                        <strong>ファイル保存手法の適用を強く推奨</strong>
                    </p>
                </div>
            </section>

            <!-- ファイル保存手法の開発で学んだ教訓 -->
            <section>
                <h2>ファイル保存手法の開発で学んだ教訓</h2>
                
                <div class="grid-2">
                    <div>
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">🤖 AIエージェントの盲点</h3>
                            <p style="font-size: 0.8em;">AIエージェントはコードを書くことはできるが、<strong>大容量データのトークン影響</strong>は人間が指摘する必要があった</p>
                        </div>
                        
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">🎯 設計の重要性</h3>
                            <p style="font-size: 0.8em;">最初にファイル保存手法の必要性を認識し、<strong>設計段階で考慮</strong>すべきだった</p>
                        </div>
                    </div>
                    <div>
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">📦 共通ユーティリティ化</h3>
                            <p style="font-size: 0.8em;">utils/file-downloader.jsに<strong>ファイル保存機能を集約</strong>し、12ツール全てで再利用</p>
                        </div>
                        
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">🔄 段階的改善</h3>
                            <p style="font-size: 0.8em;">最初は1つのツールで実装し、<strong>効果を確認後に全体に適用</strong></p>
                        </div>
                    </div>
                </div>

                <div class="problem-box">
                    <h3 style="margin-top: 0; text-align: center;">💡 最重要な学び</h3>
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>大容量APIを扱うMCP開発では、最初からファイル保存手法を検討せよ</strong><br>
                        後から修正するよりも、設計段階で組み込む方が効率的
                    </p>
                </div>
            </section>

            <!-- ファイル保存手法の具体的成果 -->
            <section>
                <h2>ファイル保存手法の具体的成果</h2>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 20px; margin: 40px 0;">
                    <div style="text-align: center;">
                        <div class="metric" style="color: #51cf66;">99.97%</div>
                        <p style="font-size: 0.7em;"><strong>トークン削減</strong><br>575,000→200</p>
                    </div>
                    <div style="text-align: center;">
                        <div class="metric" style="color: #42affa;">< 1秒</div>
                        <p style="font-size: 0.7em;"><strong>応答時間</strong><br>（従来5-10秒）</p>
                    </div>
                    <div style="text-align: center;">
                        <div class="metric" style="color: #ffa500;">∞MB</div>
                        <p style="font-size: 0.7em;"><strong>対応可能<br>ファイルサイズ</strong></p>
                    </div>
                    <div style="text-align: center;">
                        <div class="metric" style="color: #ff6b6b;">$0.004</div>
                        <p style="font-size: 0.7em;"><strong>1リクエスト<br>コスト</strong></p>
                    </div>
                </div>
                
                <div class="solution-box">
                    <h3 style="margin-top: 0; text-align: center;">ファイル保存手法の実証データ</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; font-size: 0.8em;">
                        <div>
                            <strong>🚨 従来手法（直接返却）</strong>
                            <ul style="text-align: left; color: #ff6b6b;">
                                <li>トークン: 575,000個</li>
                                <li>コスト: $11.50</li>
                                <li>応答時間: 5-10秒</li>
                                <li>制限: 〜5MB程度</li>
                            </ul>
                        </div>
                        <div>
                            <strong>✅ ファイル保存手法</strong>
                            <ul style="text-align: left; color: #51cf66;">
                                <li>トークン: 200個</li>
                                <li>コスト: $0.004</li>
                                <li>応答時間: <1秒</li>
                                <li>制限: 数百MB対応</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="highlight-box">
                    <p style="margin: 0; text-align: center; font-size: 0.9em;">
                        <strong>ROI（投資収益率）:</strong> ファイル保存手法の実装コストに対し、<br>
                        <strong>2875倍のコスト削減効果を実現</strong>
                    </p>
                </div>
            </section>

            <!-- 大容量APIでのファイル保存手法 - 他開発者への提言 -->
            <section>
                <h2>大容量APIでのファイル保存手法<br>- 他開発者への提言</h2>
                
                <div class="grid-2">
                    <div>
                        <div class="problem-box">
                            <h3 style="margin-top: 0;">⚠️ 事前チェック必須</h3>
                            <ul style="font-size: 0.8em; text-align: left;">
                                <li><strong>APIレスポンスサイズ</strong>を事前に確認</li>
                                <li><strong>1MB以上</strong>ならファイル保存手法を検討</li>
                                <li>トークン換算: 1MB ≈ 250,000トークン</li>
                                <li>コスト計算: 250,000トークン ≈ $5-10</li>
                            </ul>
                        </div>
                        
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">🤖 AIエージェント開発時</h3>
                            <ul style="font-size: 0.8em; text-align: left;">
                                <li><strong>大容量データの可能性</strong>を最初に伝える</li>
                                <li>「ファイル保存手法を検討してください」と明示</li>
                                <li>output_pathパラメータの設計を依頼</li>
                                <li>メタデータレスポンスの例を提示</li>
                            </ul>
                        </div>
                    </div>
                    <div>
                        <div class="solution-box">
                            <h3 style="margin-top: 0;">✅ 実装パターン</h3>
                            <ul style="font-size: 0.8em; text-align: left;">
                                <li><strong>ハイブリッド設計:</strong> small→JSON, large→file</li>
                                <li><strong>optional output_path</strong>で柔軟性確保</li>
                                <li><strong>ストリーミング処理</strong>でメモリ効率化</li>
                                <li><strong>メタデータ設計</strong>で必要十分な情報</li>
                            </ul>
                        </div>
                        
                        <div class="highlight-box">
                            <h3 style="margin-top: 0;">🎯 対象API例</h3>
                            <ul style="font-size: 0.8em; text-align: left;">
                                <li><strong>地理データ:</strong> OpenStreetMap, Google Maps</li>
                                <li><strong>画像/動画:</strong> メディア配信API</li>
                                <li><strong>大規模データ:</strong> 統計、ログ、検索結果</li>
                                <li><strong>ファイル配信:</strong> ダウンロードAPI全般</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="solution-box">
                    <h3 style="margin-top: 0; text-align: center;">💡 実装ガイドライン</h3>
                    <div style="font-size: 0.85em;">
                        <strong>1.</strong> APIドキュメントでレスポンスサイズを確認<br>
                        <strong>2.</strong> 1MB以上の可能性があればファイル保存手法を採用<br>
                        <strong>3.</strong> AIエージェントにはこの制約を最初に説明<br>
                        <strong>4.</strong> utils/共通処理として実装し、複数ツールで再利用
                    </div>
                </div>
            </section>

            <!-- まとめ: ファイル保存手法の結論 -->
            <section>
                <h2 style="color: #51cf66;">結論: 大容量APIデータの<br>ファイル保存手法は効果的</h2>
                
                <div class="solution-box">
                    <h3 style="margin-top: 0;">ファイル保存手法で実現できること</h3>
                    <ul style="text-align: left; font-size: 0.9em;">
                        <li>✅ <strong>99.97%トークン削減</strong> - 575,000 → 200トークン</li>
                        <li>✅ <strong>2875倍コスト削減</strong> - $11.50 → $0.004</li>
                        <li>✅ <strong>大容量データ対応</strong> - 数百MB以上も処理可能</li>
                        <li>✅ <strong>高速レスポンス</strong> - 5-10秒 → 1秒未満</li>
                    </ul>
                </div>

                <div class="problem-box">
                    <h3 style="margin-top: 0; text-align: center;">🤖 AIエージェント開発者への重要メッセージ</h3>
                    <p style="margin: 0; text-align: center; font-size: 0.95em;">
                        <strong>AIエージェントは優秀だが、大容量データのトークン影響は考慮しない</strong><br>
                        <strong>→ 人間が事前に「ファイル保存手法」の必要性を指示せよ</strong>
                    </p>
                </div>
                
                <div class="highlight-box" style="margin-top: 30px;">
                    <h3 style="margin-top: 0; text-align: center;">🎯 今すぐ行動すべきこと</h3>
                    <div style="font-size: 0.9em;">
                        <strong>1.</strong> あなたのAPIレスポンスサイズを確認<br>
                        <strong>2.</strong> 1MB以上なら即座にファイル保存手法を検討<br>
                        <strong>3.</strong> AIエージェントに制約を明確に伝える<br>
                        <strong>4.</strong> 設計段階から組み込み、後戻りコストを回避
                    </div>
                </div>
                
                <div style="margin-top: 40px; text-align: center; font-size: 1.1em; color: #51cf66;">
                    <strong>🚀 ファイル保存手法で、あなたのMCPプロジェクトも<br>コスト効率的で高性能なシステムに変身できます！</strong>
                </div>
                
                <p style="margin-top: 30px; font-size: 0.7em; color: #888; text-align: center;">
                    OpenStreetMap MCP実装詳細: GitHubリポジトリとドキュメント参照
                </p>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            backgroundTransition: 'fade',
            controls: true,
            progress: true,
            center: true,
            slideNumber: 'c/t',
            plugins: [ RevealHighlight ],
            highlight: {
                highlightOnLoad: true
            }
        });
    </script>
</body>
</html>